import { authService } from "../../services/auth";
import axios, { AxiosError } from "axios";

// Mock do axios
jest.mock("axios", () => ({
  default: {
    create: jest.fn(() => ({
      get: jest.fn(),
      post: jest.fn(),
      put: jest.fn(),
      delete: jest.fn(),
      interceptors: {
        request: {
          use: jest.fn(),
          eject: jest.fn(),
        },
        response: {
          use: jest.fn(),
          eject: jest.fn(),
        },
      },
    })),
    get: jest.fn(),
    post: jest.fn(),
    put: jest.fn(),
    delete: jest.fn(),
  },
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;
const mockAxiosInstance = (mockedAxios as any).default.create();

// Mock do localStorage
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};
Object.defineProperty(window, "localStorage", {
  value: localStorageMock,
});

// Mock do console para capturar logs de segurança
const consoleSpy = {
  error: jest.spyOn(console, "error").mockImplementation(() => {}),
  warn: jest.spyOn(console, "warn").mockImplementation(() => {}),
  log: jest.spyOn(console, "log").mockImplementation(() => {}),
};

describe("Testes de Segurança - Serviços de API", () => {
  beforeEach(() => {
    jest.clearAllMocks();
    localStorageMock.getItem.mockClear();
    localStorageMock.setItem.mockClear();
    localStorageMock.removeItem.mockClear();
    consoleSpy.error.mockClear();
    consoleSpy.warn.mockClear();
    consoleSpy.log.mockClear();
  });

  describe("AuthService - Testes de Segurança", () => {
    describe("Validação de Token JWT", () => {
      it("deve validar estrutura do token JWT", () => {
        const invalidTokens = [
          "invalid-token",
          "header.payload", // falta signature
          "header.payload.signature.extra", // muitas partes
          "", // token vazio
          null,
          undefined,
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid-payload.signature", // payload inválido
          "invalid-header.eyJzdWIiOiIxMjM0NTY3ODkwIn0.signature", // header inválido
        ];

        invalidTokens.forEach((token) => {
          localStorageMock.getItem.mockReturnValue(token);

          // Tentar usar o token inválido
          const isValid = authService.isAuthenticated();

          expect(isValid).toBe(false);
          // Token inválido deve ser removido
          expect(localStorageMock.removeItem).toHaveBeenCalledWith("token");
        });
      });

      it("deve validar expiração do token", () => {
        // Token expirado (exp no passado)
        const expiredToken =
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1MTYyMzkwMjJ9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c";

        localStorageMock.getItem.mockReturnValue(expiredToken);

        const isValid = authService.isAuthenticated();

        expect(isValid).toBe(false);
        expect(localStorageMock.removeItem).toHaveBeenCalledWith("token");
      });

      it("deve proteger contra tokens maliciosos", () => {
        const maliciousTokens = [
          // Token com payload malicioso
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI8c2NyaXB0PmFsZXJ0KCdYU1MnKTwvc2NyaXB0PiIsImV4cCI6OTk5OTk5OTk5OX0.invalid",
          // Token com claims suspeitos
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJzdXBlcmFkbWluIiwiZXhwIjo5OTk5OTk5OTk5fQ.invalid",
          // Token muito longo (possível DoS)
          "a".repeat(10000),
        ];

        maliciousTokens.forEach((token) => {
          localStorageMock.getItem.mockReturnValue(token);

          expect(() => {
            authService.isAuthenticated();
          }).not.toThrow();

          // Token malicioso deve ser removido
          expect(localStorageMock.removeItem).toHaveBeenCalledWith("token");
        });
      });
    });

    describe("Autenticação Segura", () => {
      it("deve sanitizar credenciais de login", async () => {
        const maliciousCredentials = [
          {
            email: '<script>alert("XSS")</script>@test.com',
            password: "password123",
          },
          { email: "test@test.com", password: '<script>alert("XSS")</script>' },
          {
            email: 'javascript:alert("XSS")@test.com',
            password: "password123",
          },
          {
            email: "test@test.com",
            password: 'password"; DROP TABLE users; --',
          },
        ];

        mockedAxios.post.mockResolvedValue({
          data: {
            access_token: "valid-token",
            token_type: "bearer",
            user: { id: 1, email: "test@test.com", name: "Test User" },
          },
        });

        for (const credentials of maliciousCredentials) {
          await authService.login(credentials.email, credentials.password);

          // Verificar que as credenciais foram enviadas como FormData
          expect(mockedAxios.post).toHaveBeenCalledWith(
            "/auth/token",
            expect.any(FormData),
            expect.objectContaining({
              headers: expect.objectContaining({
                "Content-Type": "multipart/form-data",
              }),
            }),
          );
        }
      });

      it("deve proteger contra ataques de timing no login", async () => {
        const startTime = Date.now();

        mockedAxios.post.mockRejectedValue(
          new AxiosError("Credenciais inválidas", "401", undefined, undefined, {
            status: 401,
            statusText: "Unauthorized",
            data: { detail: "Credenciais inválidas" },
            headers: {},
            config: {},
          } as any),
        let duration = 0;
        );

        try {
          await authService.login("test@test.com", "wrongpassword");
        } catch (error) {
          const endTime = Date.now();
          const duration = endTime - startTime;

          // Verificar que há um delay mínimo para prevenir timing attacks
          // expect moved outside try-catch - see line after catch block
        }
      });

        
        // Verificar que há um delay mínimo para prevenir timing attacks
        expect(duration).toBeGreaterThanOrEqual(100);
      it("deve limpar dados sensíveis após logout", async () => {
        localStorageMock.getItem.mockReturnValue("valid-token");

        await authService.logout();

        // Verificar que o token foi removido
        expect(localStorageMock.removeItem).toHaveBeenCalledWith("token");

        // Verificar que o usuário não está mais autenticado
        expect(authService.isAuthenticated()).toBe(false);
      });

      it("deve validar resposta do servidor", async () => {
        const maliciousResponses = [
          // Resposta com XSS
          {
            access_token: '<script>alert("XSS")</script>',
            user: { name: '<script>alert("XSS")</script>' },
          },
          // Resposta com dados suspeitos
          {
            access_token: "token",
            user: { role: "admin", permissions: ["*"] },
          },
          // Resposta malformada
          {
            token: "invalid-structure",
          },
        ];

        for (let i = 0; i < maliciousResponses.length; i++) {
          const response = maliciousResponses[i];
          mockedAxios.post.mockResolvedValue({ data: response });

          expect(() => { try {
            await authService.login("test@test.com", "password123");

            // Verificar que dados maliciosos não foram armazenados
            const storedToken = localStorageMock.setItem.mock.calls.find(
              (call) => call[0] === "token",
            );

            expect(storedToken?.[1]).not.toContain("<script>");
            expect(storedToken?.[1]).not.toContain("javascript:");
          } catch (error) {
            // Erro esperado para respostas malformadas
            expect(error).toBeDefined();
          } }).not.toThrow()
        }
      });
    });

    describe("Tratamento de Erros de Rede", () => {
      it("deve tratar timeout de requisição", async () => {
        mockedAxios.post.mockRejectedValue(
          new AxiosError(
            "Timeout",
            "ECONNABORTED",
            undefined,
            undefined,
            undefined,
          ),
        );

        await expect(
          authService.login("test@test.com", "password123"),
        ).rejects.toThrow("Timeout de conexão. Tente novamente.");
      });

      it("deve tratar erro de conexão", async () => {
        mockedAxios.post.mockRejectedValue(
          new AxiosError(
            "Network Error",
            "ERR_NETWORK",
            undefined,
            undefined,
            undefined,
          ),
        );

        await expect(
          authService.login("test@test.com", "password123"),
        ).rejects.toThrow("Erro de conexão. Verifique sua internet.");
      });

      it("deve tratar erros do servidor com segurança", async () => {
        const serverErrors = [
          { status: 500, message: "Internal Server Error" },
          { status: 502, message: "Bad Gateway" },
          { status: 503, message: "Service Unavailable" },
          { status: 429, message: "Too Many Requests" },
        ];

        for (let i = 0; i < serverErrors.length; i++) {
          const error = serverErrors[i];
          mockedAxios.post.mockRejectedValue(
            new AxiosError(
              error.message,
              error.status.toString(),
              undefined,
              undefined,
              {
                status: error.status,
                statusText: error.message,
                data: { detail: error.message },
                headers: {},
                config: {},
              } as any,
            ),
          );

          await expect(
            authService.login("test@test.com", "password123"),
          ).rejects.toThrow();

          // Verificar que erros do servidor são logados para monitoramento
          expect(consoleSpy.error).toHaveBeenCalled();
        }
      });
    });
  });

  describe("ApiService - Testes de Segurança", () => {
    describe("Interceptors de Segurança", () => {
      it("deve adicionar token de autorização automaticamente", () => {
        const validToken =
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjk5OTk5OTk5OTl9.Lkylp_o9E_aLhHJYnOKJhYjHKhqJhYjHKhqJhYjHKhq";
        localStorageMock.getItem.mockReturnValue(validToken);

        // Simular requisição
        const config = {
          url: "/api/test",
          method: "GET",
          headers: {},
        };

        // Verificar que o interceptor adiciona o token
        expect(config.headers).toBeDefined();
      });

      it("deve remover token inválido automaticamente", () => {
        const invalidToken = "invalid-token";
        localStorageMock.getItem.mockReturnValue(invalidToken);

        // Simular requisição que falha por token inválido
        const error = new AxiosError(
          "Unauthorized",
          "401",
          undefined,
          undefined,
          {
            status: 401,
            statusText: "Unauthorized",
            data: { detail: "Token inválido" },
            headers: {},
            config: {},
          } as any,
        );

        // Verificar que o token inválido é removido
        expect(localStorageMock.removeItem).toHaveBeenCalledWith("token");
      });

      it("deve proteger contra response malicioso", () => {
        const maliciousResponses = [
          {
            data: '<script>alert("XSS")</script>',
            status: 200,
          },
          {
            data: { message: 'javascript:alert("XSS")' },
            status: 200,
          },
          {
            data: { redirect: 'javascript:alert("XSS")' },
            status: 200,
          },
        ];

        maliciousResponses.forEach((response) => {
          // Verificar que responses maliciosos são tratados com segurança
          expect(() => {
            // Simular processamento da resposta
            JSON.stringify(response.data);
          }).not.toThrow();
        });
      });
    });

    describe("Rate Limiting e DoS Protection", () => {
      it("deve implementar rate limiting básico", async () => {
        const requests = [];

        // Simular múltiplas requisições simultâneas
        for (let i = 0; i < 10; i++) {
          requests.push(
            new Promise((resolve) => {
              setTimeout(() => {
                mockedAxios.get.mockResolvedValue({
                  data: { message: "success" },
                });
                resolve(mockedAxios.get("/api/test"));
              }, i * 10);
            }),
          );
        }

        await Promise.all(requests);

        // Verificar que não houve sobrecarga
        expect(mockedAxios.get).toHaveBeenCalledTimes(10);
      });

      it("deve proteger contra requisições muito grandes", () => {
        const largePayload = {
          data: "x".repeat(1000000), // 1MB de dados
        };

        // Verificar que payloads muito grandes são rejeitados ou limitados
        expect(() => {
          JSON.stringify(largePayload);
        }).not.toThrow();

        // Em uma implementação real, isso deveria ser limitado
        const serialized = JSON.stringify(largePayload);
        expect(serialized.length).toBeGreaterThan(500000);
      });
    });

    describe("Validação de URL e Endpoints", () => {
      it("deve validar URLs de API", () => {
        const maliciousUrls = [
          'javascript:alert("XSS")',
          'data:text/html,<script>alert("XSS")</script>',
          "file:///etc/passwd",
          "http://evil.com/api",
          "../../../etc/passwd",
          "api/../../admin",
        ];

        for (let i = 0; i < maliciousUrls.length; i++) {
          const url = maliciousUrls[i];
          expect(() => {
            // Verificar que URLs maliciosas são rejeitadas
            const isValid = url.startsWith("/api/") || url.startsWith("/auth/");
            expect(isValid).toBe(false);
          }).not.toThrow();
        }
      });

      it("deve sanitizar parâmetros de query", () => {
        const maliciousParams = {
          search: '<script>alert("XSS")</script>',
          filter: 'javascript:alert("XSS")',
          sort: "../../etc/passwd",
          limit: "DROP TABLE users",
        };

        // Verificar que parâmetros maliciosos são tratados como strings
        const entries = Object.entries(maliciousParams);
        for (let i = 0; i < entries.length; i++) {
          const [key, value] = entries[i];
          const encoded = encodeURIComponent(value);
          expect(encoded).not.toContain("<script>");
          expect(encoded).not.toContain("javascript:");
        }
      });
    });

    describe("Tratamento de Erros Críticos", () => {
      it("deve tratar erro de CORS com segurança", async () => {
        mockedAxios.get.mockRejectedValue(
          new AxiosError(
            "CORS error",
            "ERR_BLOCKED_BY_CORS",
            undefined,
            undefined,
            undefined,
          ),
        );

        await expect(mockedAxios.get("/api/test")).rejects.toThrow();
        
        // Verificar que erro de CORS não expõe informações sensíveis
        try {
          await mockedAxios.get("/api/test");
        } catch (error: any) {
          expect(error).toBeInstanceOf(AxiosError);
          expect(error.message).not.toContain("localhost");
          expect(error.message).not.toContain("127.0.0.1");
        }
      });

      it("deve tratar erro de SSL/TLS", async () => {
        mockedAxios.get.mockRejectedValue(
          new AxiosError(
            "SSL Error",
            "ERR_SSL_PROTOCOL_ERROR",
            undefined,
            undefined,
            undefined,
          ),
        );

        await expect(mockedAxios.get("/api/test")).rejects.toThrow();
        
        // Verificar que erro de SSL é tratado adequadamente
        try {
          await mockedAxios.get("/api/test");
        } catch (error: any) {
          expect(error).toBeInstanceOf(AxiosError);
          expect(consoleSpy.error).toHaveBeenCalled();
        }
      });

      it("deve implementar retry com backoff exponencial", async () => {
        let attemptCount = 0;

        mockedAxios.get.mockImplementation(() => {
          attemptCount++;
          if (attemptCount < 3) {
            return Promise.reject(
              new AxiosError(
                "Network Error",
                "ERR_NETWORK",
                undefined,
                undefined,
                undefined,
              ),
            );
          }
          return Promise.resolve({ data: { message: "success" } });
        });

        const startTime = Date.now();

        // Simular retry logic (seria implementado no interceptor)
        let retries = 0;
        const maxRetries = 3;

        while (retries < maxRetries) {
          try {
            await mockedAxios.get("/api/test");
            break;
          } catch (error) {
            retries++;
            if (retries < maxRetries) {
              // Backoff exponencial: 100ms, 200ms, 400ms
              const delay = Math.pow(2, retries - 1) * 100;
              await new Promise((resolve) => setTimeout(resolve, delay));
            } else {
              throw error;
            }
          }
        }

        const endTime = Date.now();
        const totalTime = endTime - startTime;

        // Verificar que houve delay apropriado (pelo menos 300ms para 2 retries)
        expect(totalTime).toBeGreaterThanOrEqual(300);
        expect(attemptCount).toBe(3);
      });
    });
  });

  describe("Testes de Integração de Segurança", () => {
    it("deve manter consistência de segurança entre serviços", async () => {
      // Testar fluxo completo: login -> requisição autenticada -> logout
      const validToken =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjk5OTk5OTk5OTl9.valid-signature";

      // Mock login bem-sucedido
      mockedAxios.post.mockResolvedValue({
        data: {
          access_token: validToken,
          token_type: "bearer",
          user: { id: 1, email: "test@test.com", name: "Test User" },
        },
      });

      await authService.login("test@test.com", "password123");

      // Verificar que o token foi armazenado
      expect(localStorageMock.setItem).toHaveBeenCalledWith(
        "token",
        validToken,
      );

      // Mock requisição autenticada
      localStorageMock.getItem.mockReturnValue(validToken);
      mockedAxios.get.mockResolvedValue({ data: { message: "success" } });

      // Fazer requisição autenticada
      await mockedAxios.get("/api/protected");

      // Verificar que a requisição foi feita com o token
      expect(mockedAxios.get).toHaveBeenCalledWith("/api/protected");

      // Logout
      await authService.logout();

      // Verificar que o token foi removido
      expect(localStorageMock.removeItem).toHaveBeenCalledWith("token");
    });

    it("deve proteger contra ataques de session fixation", async () => {
      // Simular token antigo
      const oldToken = "old-token";
      localStorageMock.getItem.mockReturnValue(oldToken);

      // Login deve gerar novo token
      const newToken = "new-token";
      mockedAxios.post.mockResolvedValue({
        data: {
          access_token: newToken,
          token_type: "bearer",
          user: { id: 1, email: "test@test.com", name: "Test User" },
        },
      });

      await authService.login("test@test.com", "password123");

      // Verificar que o token antigo foi substituído
      expect(localStorageMock.setItem).toHaveBeenCalledWith("token", newToken);
      expect(localStorageMock.getItem).not.toHaveReturnedWith(oldToken);
    });

    it("deve validar integridade dos dados em toda a cadeia", async () => {
      const testData = {
        sensitive: "password123",
        public: "public-info",
        malicious: '<script>alert("XSS")</script>',
      };

      // Verificar que dados sensíveis não são logados
      consoleSpy.log.mockClear();

      // Simular processamento de dados
      const processedData = {
        ...testData,
        sensitive: "[REDACTED]", // Dados sensíveis devem ser mascarados em logs
      };

      console.log("Processing data:", processedData);

      // Verificar que dados sensíveis não aparecem nos logs
      const logCalls = consoleSpy.log.mock.calls.flat().join(" ");
      expect(logCalls).not.toContain("password123");
      expect(logCalls).toContain("[REDACTED]");
    });
  });
});
